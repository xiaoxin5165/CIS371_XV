# Lab 1: Verilog Debugging

This lab will introduce you to the process of building, testing and debugging
Verilog code. For this and the other labs you will work on the [SEAS Biglab
machines](https://www.seas.upenn.edu/cets/answers/biglab.html). The Vivado tools
are too heavyweight to run with the time/memory limitations in place on eniac.

Note that this is an **individual lab**, so you should complete it on your own.

## Clone github repo

First, clone this repo by running, on one of the biglab machines, the command:
```
git clone https://github.com/upenn-acg/cis371.git
```

## Run the tests

We've provided a Verilog testbench with this lab, in the file
`rca_testbench.v`. A testbench is code that generates test inputs, provides each
input to a module being tested (called the UUT/DUT for "unit under test" or
"design under test"), and checks that the output is correct. Testbench code is
purely for simulation, so it can use richer constructs like loops, I/O, etc. that
cannot synthesize into real hardware.

The provided `rca_testbench.v` file tests all possible inputs for each of the
modules in `rca.v` - it is a very thorough testbench, made possible because the
UUTs are quite simple. 

You can run the tests by cd-ing into the `lab1` directory (where this file is) 
and running the command `make test`. When you run the tests on the initial 
`rca.v` code, lots of tests will fail.

> Note also that when you first run `make test` you'll encounter an error that Vivado can't be found, and to run the command `source /home1/c/cis371/software/Vivado/2017.4/settings64.sh` to fix it. This command sets up your path so that the Vivado tools are accessible. To avoid having to run this command every time you login to biglab, you can add it to your `~/.bash_profile` file and it will automatically get run every time you login.

When a test fails, it tells you that something is wrong,
but it doesn't explain why. Careful testing of each module can be helpful in
limiting the amount of code you need to examine: if we had only given tests for
the `rca4` module, and it fails a test, you don't immediately know whether the
bug is in `rca4` itself or in `fulladder2`, `fulladder`, or `halfadder`.

The process of running tests (known as simulating the design) may also generate
some warnings. These are important to understand and fix, but in general they
are a small subset of the warnings generated by the synthesis process (see
below).

Instead of investigating the test outputs right now, a more efficient way to
debug is to see if Vivado has identified any issues with the code during
synthesis. The warnings/errors identified by Vivado are usually more specific:
they explain what is wrong and often point to a specific place in the code. This
is a much easier way to find many bugs!

### xsim bug

Some people have seen an error message like this generated by the Xilinx simulator xsim when it exits:
```
*** Error in `xsim.dir/snapshot.sim/xsimk': double free or corruption (!prev): 0x00000000013dc310 ***
```
This is due to a bug in xsim, but since it's at the end of the simulation it seems to be innocuous.

## Run synthesis

Now cd to the `lab1` directory (where this file
lives) and run the command `make synth`. This will launch synthesis, and it will
take about 2 minutes to complete. If something is really wrong with a design, it
will not synthesize. But even designs with many serious problems (such as the
initial code in this lab) will synthesize successfully. Completing synthesis
doesn't mean much!

### Check Vivado log

So, after synthesis finishes running, you should examine the log files to check
for warnings. First, examine the file `vivado.log` which records everything that
was printed to the screen while synthesis ran. Some of these warnings are
benign, such as:

```
WARNING: [Synth 8-3917] design rca4 has port LED[7] driven by constant 0
```

Only 4 of the Zedboard's 8 LEDs are used in this lab, so the high-order four
LEDs (7-4) are hard-wired to zero which is fine. Other warnings are more
serious:

+ A "net without a driver" is a wire that does not have anything
connected to it, which is usually indicative of a bug.
+ A "multi-driven net" is a
wire that has too many inputs - each wire should be connected to just a single
source.
+ A "disconnected port" is an input or output
port of a module that isn't connected to anything - also likely a bug.

These warnings are hints to help you fix the bugs in this lab, and will also be
valuable hints about the bugs you encounter in future labs. As you fix bugs, you
can re-run synthesis via `make synth` to see if the warning goes away, or is
perhaps replaced by another one - sometimes one bug can mask another!


### Examine Design Rule Checks Report

After you've fixed all the important warnings from `vivado.log`, you should
examine the Design Rule Check (DRC) report in
`output/post_synth_drc_report.txt`. DRCs are additional sanity checks that
Vivado runs to make sure that the design is reasonable. Sometimes they overlap
with the warnings in `vivado.log`, but often they are separate and no less
serious.

One DRC warning that you *can* ignore is the following:
```
ZPS7-1#1 Warning
PS7 block required
The PS7 cell must be used in this Zynq design in order to enable correct default configuration.
Related violations: <none>
```

It says that all designs should have a PS7 block, which represents the embedded
ARM cores on the Zedboard's FPGA. For this class, we will use just the
"programmable logic" (Vivado calls this the "PL" sometimes) and we don't need
the ARM cores. Unfortunately, we don't know a good way to disable this warning
without also disabling other useful warnings.

There are other interesting reports in the `output/` directory. We'll dig into
these more in future labs, but here's a quick summary:

+ `post_synth_utilization.txt` shows how much of the FPGA's resources (LUTs, registers, block RAMs, etc.) were used by the design.
+ `post_synth_timing_summary_report.txt` discusses whether the design met its timing constraints or not. The modules in this lab do not have any timing constraints to satisfy, so this report is pretty vacuous for now.

## Revisiting the Tests

Even after you resolve all the warnings, it is likely that some of the tests
will still fail, because it is possible to have bugs that are pure logic
errors. If we're supposed to add two numbers but we subtract instead, Vivado
will never be able to figure this out: we can have a perfectly well-formed
circuit that just doesn't do what it's supposed to do.

To help hone in on these failing tests, you should pick just one failing test
case (a single input to a particular module) and examine it. It may be helpful
to write your own, smaller testbench (or comment out parts of `rca_testbench.v`)
so that you can run just the input of interest. Start by debugging the lowest-level
module, since those bugs may be the root cause of failures in other higher-level modules.

## Submitting Code

Once your code passes all the tests, you are ready to submit it **via Canvas**.

## Zedboard Demo

You also **need to demo** your working design on the Zedboards in the K Lab. The
toggle switches at the bottom of the Zedboard are used to input two 4-bit
integers, and their 4-bit sum is displayed on the lowest-order 4 LEDs. The TAs
will try a few different inputs to verify that your adder works as it should.

### Generating a bitstream

Run the command `make impl` to generate a `.bit` bitstream file. This will run
the *implementation* step of the FPGA design flow, mapping your design onto the
ZedBoard's hardware. It will take a few minutes. 

When implementation completes, it should create a bitstream file `output/rca4.bit`.

### Programming via Linux command line (recommended)

The simplest way to program the ZedBoards is to use the Linux machines in the K
Lab. Note that each station in the K Lab has both a Windows *and* a Linux
machine. You can switch between them via the KVM (keyboard/video/mouse) switch
beneath the monitor: the Linux machine is typically **input 2**.

Once you login to the machine, connect your ZedBoard. Note that the Linux
machines in the K Lab are the machines **with all-black USB ports on the
front**. The machines with the blue USB 3.0 ports are the Windows machines.

Follow the [instructions for connecting the
ZedBoard](https://docs.google.com/presentation/d/1spwy8Ech3oLO72_VbKN5WkDlwbWy0WWISxv_lMjhRkg/edit?usp=sharing),
and then switch to the terminal (the Konsole application works well). From the
lab1 directory, run the command `make program`. You will be prompted for the
`.bit` bitstream file you want to use, and then the FPGA should get programmed
accordingly.

#### Programming via Vivado GUI

You can also program the ZedBoard via the Vivado GUI. See [instructions for Windows here](https://docs.google.com/presentation/d/1spwy8Ech3oLO72_VbKN5WkDlwbWy0WWISxv_lMjhRkg/edit?usp=sharing). 

You can use similar instructions to program via the Vivado GUI on the K Lab Linux machines. Start Vivado by running the usual `source ...` command to get the Vivado tools onto your PATH, then run the command `vivado &` on the command line and the GUI should appear within a few moments. You can then follow the Windows tutorial linked above as the menus are identical.

In our experience, the Linux version is substantially more responsive than the Windows version (not Windows fault, it's due to the way that the Windows version of Vivado is installed onto a network drive).



